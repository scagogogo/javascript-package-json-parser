package parser

import (
	"context"
	"io/ioutil"
	"os"
	"testing"

	"github.com/scagogogo/package-json-parser/pkg/models"
	baseModels "github.com/scagogogo/sca-base-module-components/pkg/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestYarnLockParser_Parse(t *testing.T) {
	tests := []struct {
		name            string
		yarnLockContent string
		wantError       bool
		checkFunc       func(t *testing.T, project *baseModels.Project[*models.YarnLockProjectEcosystem, *models.YarnLockModuleEcosystem, *models.YarnLockComponentEcosystem, *models.YarnLockComponentDependencyEcosystem])
	}{
		{
			name: "基本 yarn.lock 解析测试",
			yarnLockContent: `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

lodash@^4.17.15:
  version "4.17.21"
  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz#679591c564c3bffaae8454cf0b3df370c3d6911c"
  integrity sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==

react@^16.8.0:
  version "16.14.0"
  resolved "https://registry.yarnpkg.com/react/-/react-16.14.0.tgz#94d776ddd0aaa37da3eda8fc5b6b18a4c9a3114d"
  integrity sha512-0X2CImDkJGApiAlcf0ODKIneSwBPhqJawOa5wCtKbu7ZECrmS26NvtSILynQ66cgkT/RJ4LidJOc3bUESwmU8g==
  dependencies:
    "loose-envify" "^1.1.0"
    "object-assign" "^4.1.1"
    "prop-types" "^15.6.2"
`,
			wantError: false,
			checkFunc: func(t *testing.T, project *baseModels.Project[*models.YarnLockProjectEcosystem, *models.YarnLockModuleEcosystem, *models.YarnLockComponentEcosystem, *models.YarnLockComponentDependencyEcosystem]) {
				assert.NotNil(t, project)

				// 检查模块数量
				assert.Len(t, project.Modules, 1, "应该有一个模块")
				// 查找模块
				var module *baseModels.Module[*models.YarnLockModuleEcosystem, *models.YarnLockComponentEcosystem, *models.YarnLockComponentDependencyEcosystem]
				for _, m := range project.Modules {
					module = m
					break // 只取第一个模块
				}
				require.NotNil(t, module, "应该能找到模块")

				// 检查依赖数量
				assert.Len(t, module.Dependencies, 2, "应该有两个依赖")

				// 检查依赖
				var lodashDep, reactDep *baseModels.ComponentDependency[*models.YarnLockComponentDependencyEcosystem]
				for i := range module.Dependencies {
					if module.Dependencies[i].DependencyName == "lodash" {
						lodashDep = module.Dependencies[i]
					} else if module.Dependencies[i].DependencyName == "react" {
						reactDep = module.Dependencies[i]
					}
				}

				// 检查 lodash 依赖
				require.NotNil(t, lodashDep, "lodash 依赖应该存在")
				assert.Equal(t, "4.17.21", lodashDep.DependencyVersion)
				assert.Equal(t, "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz", lodashDep.ComponentDependencyEcosystem.Resolved)
				assert.Equal(t, "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==", lodashDep.ComponentDependencyEcosystem.Integrity)

				// 检查 react 依赖
				require.NotNil(t, reactDep, "react 依赖应该存在")
				assert.Equal(t, "16.14.0", reactDep.DependencyVersion)
				assert.Equal(t, "https://registry.yarnpkg.com/react/-/react-16.14.0.tgz", reactDep.ComponentDependencyEcosystem.Resolved)
			},
		},
		{
			name: "复杂嵌套依赖测试",
			yarnLockContent: `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

"@babel/code-frame@^7.0.0":
  version "7.12.13"
  resolved "https://registry.yarnpkg.com/@babel/code-frame/-/code-frame-7.12.13.tgz"
  integrity sha512-HV1Cm0Q3ZrpCR93tkWOYiuYIgLxZXZFVG2VgK+MBWjUqZTundupbfx2aXarXuw5Ko5aMcjtJgbSs4vUGBS5v6g==
  dependencies:
    "@babel/highlight" "^7.12.13"

"@babel/core@^7.7.5":
  version "7.13.8"
  resolved "https://registry.yarnpkg.com/@babel/core/-/core-7.13.8.tgz"
  integrity sha512-oYapIySGw1zGhEFRd6lzWNLWFX2s5dA/jm+Pw/+59ZdXtjyIuwlXbrId22Md0rgZVop+aVoqow2riXhBLNyuQQ==
  dependencies:
    "@babel/code-frame" "^7.12.13"
    "@babel/generator" "^7.13.0"
    "@babel/helper-validator-option" "^7.12.17"
    "@babel/parser" "^7.13.4"
    "@babel/template" "^7.12.13"
    "@babel/traverse" "^7.13.0"
    "@babel/types" "^7.13.0"

"@babel/highlight@^7.12.13":
  version "7.13.8"
  resolved "https://registry.yarnpkg.com/@babel/highlight/-/highlight-7.13.8.tgz"
  integrity sha512-4vrIhfJyfNf+lCtXC2ck1rKSzDwciqF7IWFhXXrSOUC2O5DrVp+w4c6ed4AllTxhTkUP5x2tYj41VaxdVMMRDw==
  dependencies:
    "@babel/helper-validator-identifier" "^7.12.11"
    "chalk" "^2.0.0"
    "js-tokens" "^4.0.0"
`,
			wantError: false,
			checkFunc: func(t *testing.T, project *baseModels.Project[*models.YarnLockProjectEcosystem, *models.YarnLockModuleEcosystem, *models.YarnLockComponentEcosystem, *models.YarnLockComponentDependencyEcosystem]) {
				assert.NotNil(t, project)
				assert.Len(t, project.Modules, 1, "应该有一个模块")
				// 查找模块
				var module *baseModels.Module[*models.YarnLockModuleEcosystem, *models.YarnLockComponentEcosystem, *models.YarnLockComponentDependencyEcosystem]
				for _, m := range project.Modules {
					module = m
					break // 只取第一个模块
				}
				require.NotNil(t, module, "应该能找到模块")

				// 应该有3个顶级依赖
				assert.GreaterOrEqual(t, len(module.Dependencies), 3, "应该至少有3个顶级依赖")

				// 检查特定依赖
				var codeFrameDep, coreDep, highlightDep *baseModels.ComponentDependency[*models.YarnLockComponentDependencyEcosystem]
				for i := range module.Dependencies {
					if module.Dependencies[i].DependencyName == "@babel/code-frame" {
						codeFrameDep = module.Dependencies[i]
					} else if module.Dependencies[i].DependencyName == "@babel/core" {
						coreDep = module.Dependencies[i]
					} else if module.Dependencies[i].DependencyName == "@babel/highlight" {
						highlightDep = module.Dependencies[i]
					}
				}

				// 检查 @babel/core 依赖
				require.NotNil(t, coreDep, "@babel/core 依赖应该存在")
				assert.Equal(t, "7.13.8", coreDep.DependencyVersion)

				// 检查 @babel/code-frame 依赖
				require.NotNil(t, codeFrameDep, "@babel/code-frame 依赖应该存在")
				assert.Equal(t, "7.12.13", codeFrameDep.DependencyVersion)

				// 检查 @babel/highlight 依赖
				require.NotNil(t, highlightDep, "@babel/highlight 依赖应该存在")
				assert.Equal(t, "7.13.8", highlightDep.DependencyVersion)
			},
		},
		{
			name:            "无效格式测试",
			yarnLockContent: `This is not a valid yarn.lock file`,
			wantError:       true,
		},
		{
			name:            "空文件测试",
			yarnLockContent: ``,
			wantError:       true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 创建临时文件
			tmpFile, err := os.CreateTemp("", "yarn-lock-test-*.lock")
			require.NoError(t, err)
			defer os.Remove(tmpFile.Name())

			// 写入内容
			err = ioutil.WriteFile(tmpFile.Name(), []byte(tt.yarnLockContent), 0644)
			require.NoError(t, err)

			// 解析测试
			parser := NewYarnLockParser()
			err = parser.Init(context.Background())
			require.NoError(t, err)

			input := &YarnLockParserInput{
				YarnLockPath: tmpFile.Name(),
			}

			project, err := parser.Parse(context.Background(), input)

			if tt.wantError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, project)

				if tt.checkFunc != nil {
					tt.checkFunc(t, project)
				}
			}
		})
	}
}

// 测试解析器的各个方法
func TestYarnLockParser_Methods(t *testing.T) {
	// 测试GetName方法
	t.Run("GetName", func(t *testing.T) {
		parser := NewYarnLockParser()
		assert.Equal(t, YarnLockParserName, parser.GetName())
	})

	// 测试Init方法
	t.Run("Init", func(t *testing.T) {
		parser := NewYarnLockParser()
		err := parser.Init(context.Background())
		assert.Nil(t, err)
	})

	// 测试Close方法
	t.Run("Close", func(t *testing.T) {
		parser := NewYarnLockParser()
		err := parser.Close(context.Background())
		assert.Nil(t, err)
	})
}

// 测试提取包名相关功能
func TestYarnLockParser_ExtractPackageName(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{
			input:    "lodash@^4.17.15",
			expected: "lodash",
		},
		{
			input:    "@babel/core@^7.7.5",
			expected: "@babel/core",
		},
		{
			input:    "@babel/preset-env@7.13.8",
			expected: "@babel/preset-env",
		},
		{
			input:    "weird-package@1.0.0-beta.1",
			expected: "weird-package",
		},
	}

	// 使用YarnLockParser的extractPackageName方法进行测试
	parser := NewYarnLockParser()
	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			pkgName := parser.extractPackageName(tt.input)
			assert.Equal(t, tt.expected, pkgName)
		})
	}
}

func TestYarnLockParser_Close(t *testing.T) {
	parser := NewYarnLockParser()
	err := parser.Close(context.Background())
	assert.Nil(t, err)
}
